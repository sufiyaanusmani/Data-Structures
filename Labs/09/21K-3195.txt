**************************************
*************** TASK 1 ***************
**************************************

// Sufiyaan Usmani
// 21K-3195
// BCS-3J
// Question 1

#include <iostream>
using namespace std;

class Stack
{
private:
    int size;
    int top;
    int *arr;

public:
    Stack(int size)
    {
        this->size = size;
        arr = new int[this->size];
        top = -1;
    }

    bool isEmpty()
    {
        if (top == -1)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    bool isFull()
    {
        if (top == size - 1)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    void push(int data)
    {
        if (isFull())
        {
            cout << "Stack Overflow" << endl;
        }
        else
        {
            top++;
            arr[top] = data;
        }
    }

    int pop()
    {
        int x = -1;
        if (isEmpty())
        {
            cout << "Stack is empty" << endl;
        }
        else
        {
            x = arr[top];
            top--;
        }
        return x;
    }

    bool isSafe(int index)
    {
        if (index >= 0 && index <= top)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    int peek()
    {
        int x = 0;
        if (isEmpty())
        {
            cout << "Stack is empty" << endl;
        }
        else
        {
            x = arr[top];
        }
        return x;
    }

    void print()
    {
        if (isEmpty())
        {
            cout << "Stack is empty" << endl;
        }
        else
        {
            for (int i = top; i >= 0; i--)
            {
                cout << arr[i] << endl;
            }
        }
        cout << endl;
    }

    ~Stack()
    {
        if (arr != NULL)
        {
            delete[] arr;
        }
        arr = NULL;
    }
};

int main(){
    Stack stack(10);
    // part 1
    stack.push(10);
    stack.push(20);
    stack.push(30);
    stack.push(40);
    stack.push(50);
    stack.push(60);
    stack.push(70);
    stack.push(80);
    stack.push(90);
    stack.push(100);
    stack.print();

    // part 2
    cout << "Inserting 110 to full stack" << endl;
    stack.push(110);

    // part 3
    cout << endl;

    while(!stack.isEmpty()){
        cout << "Popping: " << stack.peek() << endl;
        stack.pop();
    }
    cout << "\nTrying to pop from empty stack" << endl;
    stack.pop();
    return 0;
}

**************************************
*************** TASK 2 ***************
**************************************

// Sufiyaan Usmani
// 21K-3195
// BCS-3J
// Question 2

#include <iostream>
using namespace std;

class Node
{
public:
    int data;
    Node *next;

    Node()
    {
        data = 0;
        next = NULL;
    }

    Node(int data)
    {
        this->data = data;
        next = NULL;
    }
};

class Stack
{
private:
    Node *top;
public:
    Stack()
    {
        top = NULL;
    }

    bool isEmpty(){
        if(top == NULL){
            return true;
        }else{
            return false;
        }
    }

    void printForward(){
        // from bottom to top
        Stack temp;
        while(!isEmpty()){
            temp.push(peek());
            pop();
        }
        while(!temp.isEmpty()){
            cout << temp.peek() << "  ";
            push(temp.peek());
            temp.pop();
        }
        cout << endl;
    }

    void printReversed(){
        // from top to bottom
        Stack temp;
        while(!isEmpty()){
            cout << peek() << "  ";
            temp.push(peek());
            pop();
        }
        while(!temp.isEmpty()){
            push(temp.peek());
            temp.pop();
        }
        cout << endl;
    }

    void push(int data)
    {
        Node *n = new Node(data);
        if (n == NULL)
        {
            // if heap is full
            cout << "Heap Overflow" << endl;
        }
        else
        {
            n->next = top;
            top = n;
        }
    }

    int pop()
    {
        int x = -1;
        if (top == NULL)
        {
            cout << "Stack is empty" << endl;
        }
        else
        {
            Node *temp = top;
            top = top->next;
            x = temp->data;
            delete temp;
        }
        return x;
    }

    int peek(){
        if(top == NULL){
            return -1;
        }else{
            return top->data;
        }
    }
};

int main(){
    Stack stack;
    // part 1
    stack.push(10);
    stack.push(20);
    stack.push(30);
    stack.push(40);
    stack.push(50);
    stack.push(60);
    stack.push(70);
    stack.push(80);
    stack.push(90);
    stack.push(100);

    cout << "Printing stack in forward direction:" << endl;
    stack.printForward();

    cout << "\nPrinting stack in reversed direction:" << endl;
    stack.printReversed();

    cout << "\nPopping " << stack.peek() << endl;
    stack.pop();
    return 0;
}

**************************************
*************** TASK 3 ***************
**************************************

// Sufiyaan Usmani
// 21K-3195
// BCS-3J
// Question 3

#include <iostream>
#include <stack>
using namespace std;


int getPrecedence(char c)
{
	if (c == '^')
		return 3;
	else if (c == '/' || c == '*')
		return 2;
	else if (c == '+' || c == '-')
		return 1;
	else
		return -1;
}

string infixToPostfix(string infix)
{
	stack<char> st;
	string result = "";

	for (int i = 0; i < infix.length(); i++) {
		char ch = infix[i];

		if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')){
			result += ch;
        }else if (ch == '('){
			st.push('(');
		}else if (ch == ')'){
			while (st.top() != '('){
				result += st.top();
				st.pop();
			}
			st.pop();
		}
		else{
			while (!st.empty() && getPrecedence(infix[i]) <= getPrecedence(st.top())) {
				result += st.top();
				st.pop();
			}
			st.push(ch);
		}
	}

    // Popping remaining elements
	while (!st.empty()) {
		result += st.top();
		st.pop();
	}

	return result;
}

int main()
{
	string infix = "a+b*(c^d-e)^(f+g*h)-i";
	cout << "Infix: " << infix << endl;
	cout << "Postfix: " << infixToPostfix(infix) << endl;
	return 0;
}

**************************************
*************** TASK 4 ***************
**************************************

// Sufiyaan Usmani
// 21K-3195
// BCS-3J
// Question 4

#include <iostream>
using namespace std;

class Queue{
    private:
        int front, rear, size, capacity;
        int *arr;

    public:
        Queue(int capacity=0){
            this->capacity = capacity;
            arr = new int[this->capacity];
            front = rear = -1;
            size = 0;
        }

        bool isEmpty(){
            if(front == -1 && rear == -1 && size == 0){
                return true;
            }else{
                return false;
            }
        }

        bool isFull(){
            if(rear == capacity - 1){
                return true;
            }else{
                return false;
            }
        }

        void addMember(int data){
            if(isFull()){
                cout << "Queue is full" << endl;
            }else{
                if(isEmpty()){
                    front = rear = 0;
                }else{
                    rear++;
                }
                arr[rear] = data;
                size++;
            }
        }

        void removeMember(){
            if(isEmpty()){
                cout << "Queue is empty" << endl;
            }else{
                arr[front] = 0;
                if(front == rear){
                    front = rear = -1;
                }else{
                    front++;
                }
                size--;
            }
        }

        int queueCapacity(){
            if(rear == capacity - 1){
                cout << "Queue is full" << endl;
            }
        }

        void print(){
            if(isEmpty()){
                cout << "Queue is empty" << endl;
            }else{
                for(int i=front;i<=rear;i++){
                    cout << arr[i] << "  ";
                }
                cout << endl;
            }
        }
};

int main(){
    int n;
    cout << "Enter size of queue: ";
    cin >> n;
    Queue queue(n);
    while(1){
        cout << "\nQueue: ";
        queue.print();
        cout << "\n1. Add Member" << endl;
        cout << "2. Remove Member" << endl;
        cout << "3. Exit" << endl << endl;
        cout << "Enter your choice: ";
        cin >> n;
        
        if(n == 1){
            cout << "Enter data to add: ";
            cin >> n;
            queue.addMember(n);
        }else if(n == 2){
            queue.removeMember();
        }else if(n == 3){
            break;
        }else{
            cout << "Wrong choice entered" << endl;
        }
    }
    return 0;
}

**************************************
*************** TASK 5 ***************
**************************************

// Sufiyaan Usmani
// 21K-3195
// BCS-3J
// Question 5

#include <iostream>
using namespace std;

class Node
{
public:
    int data;
    Node *next;

    Node()
    {
        this->data = 0;
        next = NULL;
    }

    Node(int data)
    {
        this->data = data;
        next = NULL;
    }
};

class Queue
{
private:
    Node *front;
    Node *rear;

public:
    Queue()
    {
        front = rear = NULL;
    }

    bool isEmpty()
    {
        if (front == NULL && rear == NULL)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    void print()
    {
        if (isEmpty())
        {
            cout << "Queue is empty" << endl;
        }
        else
        {
            Node *temp = front;
            while (temp != NULL)
            {
                cout << temp->data << "  ";
                temp = temp->next;
            }
            cout << endl;
        }
    }

    void addMember(int data)
    {
        Node *n = new Node(data);
        if(n == NULL)
        {
            // acting as Queue capacity
            cout << "Heap Overflow" << endl;
            return;
        }
        else
        {
            if (isEmpty())
            {
                front = rear = n;
            }
            else
            {
                rear->next = n;
                rear = n;
            }
        }
    }

    int removeMember()
    {
        int data = -1;
        if (isEmpty())
        {
            cout << "Queue is empty" << endl;
        }
        else
        {
            Node *temp = front;
            front = front->next;
            data = temp->data;
            delete temp;
        }
        return data;
    }
};

int main()
{
    Queue queue;
    queue.addMember(10);
    queue.addMember(20);
    queue.addMember(30);
    queue.print();
    queue.removeMember();
    queue.print();
    return 0;
}

**************************************
*************** TASK 6 ***************
**************************************

// Sufiyaan Usmani
// 21K-3195
// BCS-3J
// Question 6

#include <iostream>
#include <stdlib.h>
#include <conio.h>
#include <stack>
using namespace std;

class TextEditor{
    private:
        stack<char> st1, st2;
        // st1 is main stack where string is stored
        // if undo, then top character is popped from st1 and pushed to st2
        // if redo, then top character is popped from st2 and pushed to st1 
    public:
        TextEditor(string text){
            for(int i=0;i<text.length();i++){
                st1.push(text[i]);
            }
        }

        void print(){
            stack<char> temp;
            while(!st1.empty()){
                temp.push(st1.top());
                st1.pop();
            }
            while(!temp.empty()){
                cout << temp.top();
                st1.push(temp.top());
                temp.pop();
            }
            cout << endl;
        }

        void undo(){
            if(!st1.empty()){
                st2.push(st1.top());
                st1.pop();
            }
        }

        void redo(){
            if(!st2.empty()){
                st1.push(st2.top());
                st2.pop();
            }
        }
};

int main(){
    string str;
    char ch;
    cout << "Enter text: ";
    getline(cin, str);
    TextEditor editor(str);
    cout << "Press 1 to undo and 2 to redo" << endl;
    while(1){
        ch = getch();
        if(ch == '1'){
            editor.undo();
            editor.print();
        }else if(ch == '2'){
            editor.redo();
            editor.print();
        }
    }
    return 0;
}

**************************************
*************** TASK 7 ***************
**************************************

// Sufiyaan Usmani
// 21K-3195
// BCS-3J
// Question 7

#include <iostream>
#include <stack>
using namespace std;

bool isValid(string str){
    stack<char> st;
    for(int i=0;i<str.length();i++){
        if(str[i] == '(' || str[i] == '{' || str[i] == '['){
            st.push(str[i]);
        }else if(str[i] == ')'){
            if(st.top() == '('){
                st.pop();
            }else{
                return false;
            }
        }else if(str[i] == '}'){
            if(st.top() == '{'){
                st.pop();
            }else{
                return false;
            }
        }else if(str[i] == ']'){
            if(st.top() == '['){
                st.pop();
            }else{
                return false;
            }
        }
    }
    if(st.empty()){
        return true;
    }else{
        return false;
    }
}

int main(){
    string str1 = "{()}[]";
    cout << "String: " << str1 << endl;
    if(isValid(str1)){
        cout << "String is valid" << endl;
    }else{
        cout << "String is invalid" << endl;
    }

    string str2 = "{(}[";
    cout << "\nString: " << str2 << endl;
    if(isValid(str2)){
        cout << "String is valid" << endl;
    }else{
        cout << "String is invalid" << endl;
    }
    return 0;
}

**************************************
*************** TASK 8 ***************
**************************************

// Sufiyaan Usmani
// 21K-3195
// BCS-3J
// Question 8

#include <iostream>
using namespace std;

class Node{
    public:
        int data;
        Node *left;
        Node *right;

        Node(int data=0){
            this->data = data;
            left = right = NULL;
        }
};

class BST{
    public:
        Node *root;

        BST(){
            root = NULL;
        }

        bool isEmpty(){
            if(root == NULL){
                return true;
            }else{
                return false;
            }
        }

        Node *insert(Node *r, int data){
            if(r == NULL){
                r = new Node(data);
                return r;
            }
            
            if(data < r->data){
                r->left = insert(r->left, data);
            }else if(data > r->data){
                r->right = insert(r->right, data);
            }else{
                cout << "Duplicates not allowed" << endl;
                return r;
            }
            return r;
        }

        void inorder(Node *r){
            if(r == NULL){
                return;
            }
            inorder(r->left);
            cout << r->data << "  ";
            inorder(r->right);
        }

        int height(Node *r){
            if(r == NULL){
                return -1;
            }else{
                int leftHeight = height(r->left);
                int rightHeight = height(r->right);
                if(leftHeight > rightHeight){
                    return(leftHeight + 1);
                }else{
                    return(rightHeight + 1);
                }
            }
        }

        int getBalanceFactor(Node *r){
            if(r == NULL){
                return -1;
            }
            return (height(r->left) - height(r->right));
        }

        void printBalanceFactors(Node *r){
            // printing balance factors in preorder fashion
            if(r == NULL){
                return;
            }
            cout << "Balance factor of " << r->data << ": " << getBalanceFactor(r) << endl;
            printBalanceFactors(r->left);
            printBalanceFactors(r->right);
        }
};

int main(){
    BST tree;
    tree.root = tree.insert(tree.root, 10);
    tree.root = tree.insert(tree.root, 15);
    tree.root = tree.insert(tree.root, 5);
    tree.root = tree.insert(tree.root, 20);
    tree.root = tree.insert(tree.root, 25);
    tree.inorder(tree.root);
    cout << "\n\n";
    tree.printBalanceFactors(tree.root);
    return 0;
}

**************************************
*************** TASK 9 ***************
**************************************

// Sufiyaan Usmani
// 21K-3195
// BCS-3J
// Question 9

#include <iostream>
using namespace std;

class Node{
    public:
        int data;
        Node *left;
        Node *right;

        Node(int data=0){
            this->data = data;
            left = right = NULL;
        }
};

class AVL{
    public:
        Node *root;

        AVL(){
            root = NULL;
        }

        bool isEmpty(){
            if(root == NULL){
                return true;
            }else{
                return false;
            }
        }

        int height(Node *r){
            if(r == NULL){
                return -1;
            }else{
                int leftHeight = height(r->left);
                int rightHeight = height(r->right);
                if(leftHeight > rightHeight){
                    return(leftHeight + 1);
                }else{
                    return(rightHeight + 1);
                }
            }
        }

        int getBalanceFactor(Node *r){
            if(r == NULL){
                return -1;
            }
            return(height(r->left) - height(r->right));
        }

        Node *insert(Node *r, int data){
            if(r == NULL){
                r = new Node(data);
                return r;
            }

            if(data < r->data){
                r->left = insert(r->left, data);
            }else if(data > r->data){
                r->right = insert(r->right, data);
            }else{
                cout << "Duplicates not allowed" << endl;
                return r;
            }

            int bf = getBalanceFactor(r);
            if(bf > 1 && data < r->left->data){
                return rightRotate(r);
            }
            if(bf < -1 && data > r->right->data){
                return leftRotate(r);
            }
            if(bf > 1 && data > r->left->data){
                r->left = leftRotate(r->left);
                return rightRotate(r);
            }
            if(bf < -1 && data < r->right->data){
                r->right = rightRotate(r->right);
                return leftRotate(r);
            }
            return r;
        }

        Node *leftRotate(Node *r){
            Node *y = r->right;
            Node *temp = y->left;

            y->left = r;
            r->right = temp;

            return y;
        }

        Node *rightRotate(Node *r){
            Node *x = r->left;
            Node *temp = x->right;

            x->right = r;
            r->left = temp;

            return x;
        }

        void printBalanceFactors(Node *r){
            // printing balance factors in preorder fashion
            if(r == NULL){
                return;
            }
            cout << "Balance factor of " << r->data << ": " << getBalanceFactor(r) << endl;
            printBalanceFactors(r->left);
            printBalanceFactors(r->right);
        }

        void inorder(Node *r){
            if(r == NULL){
                return;
            }
            inorder(r->left);
            cout << r->data << "  ";
            inorder(r->right);
        }
};

int main(){
    AVL tree;
    tree.root = tree.insert(tree.root, 10);
    tree.root = tree.insert(tree.root, 15);
    tree.root = tree.insert(tree.root, 5);
    tree.root = tree.insert(tree.root, 20);
    tree.root = tree.insert(tree.root, 25);
    tree.inorder(tree.root);
    cout << "\n\n";
    tree.printBalanceFactors(tree.root);
    return 0;
}

**************************************
*************** TASK 10 **************
**************************************

// Sufiyaan Usmani
// 21K-3195
// BCS-3J
// Question 10

#include <iostream>
using namespace std;

class Node{
    public:
        int data;
        Node *left;
        Node *right;

        Node(int data=0){
            this->data = data;
            left = right = NULL;
        }
};

class BST{
    public:
        Node *root;

        BST(){
            root = NULL;
        }

        bool isEmpty(){
            if(root == NULL){
                return true;
            }else{
                return false;
            }
        }

        Node *insert(Node *r, int data){
            if(r == NULL){
                r = new Node(data);
                return r;
            }

            if(data < r->data){
                r->left = insert(r->left, data);
            }else if(data > r->data){
                r->right = insert(r->right, data);
            }else{
                cout << "Duplicates not allowed" << endl;
                return r;
            }
            return r;
        }

        int height(Node *r){
            if(r == NULL){
                return -1;
            }else{
                int leftHeight = height(r->left);
                int rightHeight = height(r->right);
                if(leftHeight > rightHeight){
                    return(leftHeight + 1);
                }else{
                    return(rightHeight + 1);
                }
            }
        }

        int getBalanceFactor(Node *r){
            if(r == NULL){
                return -1;
            }
            return(height(r->left) - height(r->right));
        }

        bool isBST(){
            int n = countNodes(root);
            int *arr = new int[n];
            fillInorder(root, arr);
            return(isSorted(arr, n));
        }

        void fillInorder(Node *r, int *arr){
            static int i = 0;
            if(r == NULL){
                return;
            }
            fillInorder(r->left, arr);
            arr[i] = r->data;
            i++;
            fillInorder(r->right, arr);
        }

        bool isSorted(int *arr, int n){
            for(int i=0;i<n-1;i++){
                if(arr[i] > arr[i+1]){
                    return false;
                }
            }
            return true;
        }

        int countNodes(Node *r){
            if(r == NULL){
                return 0;
            }else{
                int leftCount = countNodes(r->left);
                int rightCount = countNodes(r->right);
                return(leftCount + rightCount + 1);
            }
        }

        bool isBalanced(Node *r){
            if(r == NULL){
                return true;
            }
            if(getBalanceFactor(r) < -1 || getBalanceFactor(r) > 1){
                return false;
            }
            isBalanced(r->left);
            isBalanced(r->right);
        }

        bool isAVL(){
            if(isBST() && isBalanced(root)){
                return true;
            }else{
                return false;
            }
        }
};

int main(){
    BST tree;
    tree.root = tree.insert(tree.root, 10);
    tree.root = tree.insert(tree.root, 20);
    tree.root = tree.insert(tree.root, 30);
    tree.root = tree.insert(tree.root, 40);
    tree.root = tree.insert(tree.root, 50);
    tree.root = tree.insert(tree.root, 5);
    tree.root = tree.insert(tree.root, 6);
    tree.root = tree.insert(tree.root, 23);
    if(tree.isBST()){
        cout << "It is a BST Tree ";
        if(tree.isAVL()){
            cout << "and AVL Tree" << endl;
        }else{
            cout << "but not AVL" << endl;
        }
    }else{
        cout << "It is not BST and not AVL" << endl;
    }
    return 0;
}

**************************************
*************** TASK 11 **************
**************************************

// Sufiyaan Usmani
// 21K-3195
// BCS-3J
// Question 9

#include <iostream>
using namespace std;

class Node{
    public:
        int data;
        Node *left;
        Node *right;

        Node(int data=0){
            this->data = data;
            left = right = NULL;
        }
};

class AVL{
    public:
        Node *root;

        AVL(){
            root = NULL;
        }

        bool isEmpty(){
            if(root == NULL){
                return true;
            }else{
                return false;
            }
        }

        int height(Node *r){
            if(r == NULL){
                return -1;
            }else{
                int leftHeight = height(r->left);
                int rightHeight = height(r->right);
                if(leftHeight > rightHeight){
                    return(leftHeight + 1);
                }else{
                    return(rightHeight + 1);
                }
            }
        }

        int getBalanceFactor(Node *r){
            if(r == NULL){
                return -1;
            }
            return(height(r->left) - height(r->right));
        }

        Node *insert(Node *r, int data){
            if(r == NULL){
                r = new Node(data);
                return r;
            }

            if(data < r->data){
                r->left = insert(r->left, data);
            }else if(data > r->data){
                r->right = insert(r->right, data);
            }else{
                cout << "Duplicates not allowed" << endl;
                return r;
            }

            int bf = getBalanceFactor(r);
            if(bf > 1 && data < r->left->data){
                return rightRotate(r);
            }
            if(bf < -1 && data > r->right->data){
                return leftRotate(r);
            }
            if(bf > 1 && data > r->left->data){
                r->left = leftRotate(r->left);
                return rightRotate(r);
            }
            if(bf < -1 && data < r->right->data){
                r->right = rightRotate(r->right);
                return leftRotate(r);
            }
            return r;
        }

        Node *leftRotate(Node *r){
            Node *y = r->right;
            Node *temp = y->left;

            y->left = r;
            r->right = temp;

            return y;
        }

        Node *rightRotate(Node *r){
            Node *x = r->left;
            Node *temp = x->right;

            x->right = r;
            r->left = temp;

            return x;
        }

        void printBalanceFactors(Node *r){
            // printing balance factors in preorder fashion
            if(r == NULL){
                return;
            }
            cout << "Balance factor of " << r->data << ": " << getBalanceFactor(r) << endl;
            printBalanceFactors(r->left);
            printBalanceFactors(r->right);
        }

        void inorder(Node *r){
            if(r == NULL){
                return;
            }
            inorder(r->left);
            cout << r->data << "  ";
            inorder(r->right);
        }

        void insert(int arr[], int n){
            for(int i=0;i<n;i++){
                root = insert(root, arr[i]);
            }
        }
};

int main(){
    AVL tree;
    int arr[] = {2, 4, 5, 10, 20, 8, 9, 11, 18};
    int n = sizeof(arr) / sizeof(arr[0]);
    tree.insert(arr, n);
    tree.inorder(tree.root);
    cout << endl;
    tree.printBalanceFactors(tree.root);
    return 0;
}